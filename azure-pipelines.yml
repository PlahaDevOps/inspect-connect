trigger:
  batch: true
  branches:
    include:
      - main                # Only push/merge to main triggers CI/CD
  paths:
    include:
      - client/**
      - server/**
      - azure-pipelines.yml

pr: none                    # Disable PR validation runs for this pipeline

variables:
  nodeVersion: '20.x'
  npmCacheDir: '$(Pipeline.Workspace)/.npm'

  environment: 'production'
  azureSubscription: 'inspect-connect-appservice'
  resourceGroupName: 'inspect_connect-rg'

  frontendAppName: 'inspect-connect-test'
  backendAppName:  'inspect-connect-api-test'
  
  # Build stability
  NODE_OPTIONS: '--max-old-space-size=4096'
  npm_config_legacy_peer_deps: 'true'
  npm_config_prefer_offline: 'true'
  npm_config_audit: 'false'
  CI: 'true'

stages:
# =========================
# Stage 1: Build (FE & BE)
# =========================
- stage: Build
  displayName: Build Frontend & Backend
  jobs:
  - job: BuildAll
    displayName: Build
    pool:
      name: 'inspect-connect-agents'

    steps:
    - checkout: self

    - task: NodeTool@0
      inputs: { versionSpec: $(nodeVersion) }
      displayName: Use Node.js $(nodeVersion)

    # NEW: upgrade npm to v11 (fixes optional-deps bug that breaks Rollup native binary)
    - script: |
        set -euo pipefail
        echo "Node:"; node -v
        echo "npm (before):"; npm -v || true
        npm i -g npm@11.5.2
        echo "npm (after):"; npm -v
      displayName: 'Upgrade npm to 11.x'

    # Resolve backend default hostname for VITE_API_URL
    - task: AzureCLI@2
      displayName: 'Resolve BE defaultHostName'
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail
          az config set core.only_show_errors=true
          HOST=$(az webapp show -g $(resourceGroupName) -n $(backendAppName) --query defaultHostName -o tsv)
          echo "Resolved backend host: $HOST"
          echo "##vso[task.setvariable variable=BACKEND_HOST]$HOST"

    # -------- Frontend --------
    - task: Cache@2
      displayName: 'FE: Restore npm cache'
      inputs:
        key: 'npm | client | $(Agent.OS) | $(Build.SourcesDirectory)/client/package-lock.json'
        path: '$(Pipeline.Workspace)/.npm'
        restoreKeys: |
          npm | client | $(Agent.OS)

    - script: |
        set -euo pipefail
        npm config set cache "$(npmCacheDir)"

        echo "Installing FE deps (lock-aware)..."
        if [ -f package-lock.json ]; then
          npm ci --legacy-peer-deps --prefer-offline --no-audit || npm install --legacy-peer-deps --prefer-offline --no-audit
        else
          npm install --legacy-peer-deps --prefer-offline --no-audit
        fi

        # Verify Rollup can load native binary; if not, install the correct platform package and rebuild.
        echo "Verifying Rollup native binary..."
        node -e "try{require('rollup');process.exit(0)}catch(e){process.exit(42)}" || (
          echo "Rollup native missing; attempting platform-specific install..."
          PKG=$(node -e "const p=process.platform,a=process.arch;let n='';
            if(p==='darwin'&&a==='x64') n='@rollup/rollup-darwin-x64';
            else if(p==='darwin'&&a==='arm64') n='@rollup/rollup-darwin-arm64';
            else if(p==='linux'&&a==='x64') n='@rollup/rollup-linux-x64-gnu';
            else if(p==='linux'&&a==='arm64') n='@rollup/rollup-linux-arm64-gnu';
            else if(p==='win32'&&a==='x64') n='@rollup/rollup-win32-x64-msvc';
            console.log(n)")
          if [ -n "$PKG" ]; then
            echo "Installing $PKG ..."
            npm i -D "$PKG" || true
          else
            echo "Unknown platform/arch for Rollup native; continuing without explicit install"
          fi
          echo "Rebuilding rollup (best-effort)..."
          npm rebuild rollup --update-binary || true
        )

        echo "Running TypeScript typecheck (non-blocking)..."
        npm run typecheck > fe-typecheck.txt || true

        echo "Building FE..."
        npm run build || npx vite build

        # Assert artifact exists
        [ -d dist ] || { echo "‚ùå FE dist/ not found after build"; ls -la; exit 1; }
        echo "‚úÖ FE dist/ present"
      workingDirectory: client
      displayName: 'FE: Install, fix Rollup if needed, Typecheck (soft), Build'
      env:
        VITE_API_URL: "https://$(BACKEND_HOST)"

    - task: PublishPipelineArtifact@1
      displayName: 'FE: Publish typecheck report'
      inputs:
        targetPath: '$(Build.SourcesDirectory)/client/fe-typecheck.txt'
        artifact: 'fe-typecheck'

    - task: ArchiveFiles@2
      displayName: 'FE: Package dist'
      inputs:
        rootFolderOrFile: '$(Build.SourcesDirectory)/client/dist'
        includeRootFolder: false
        archiveType: zip
        archiveFile: '$(Build.ArtifactStagingDirectory)/frontend.zip'
        replaceExistingArchive: true

    - task: PublishPipelineArtifact@1
      displayName: 'FE: Publish artifact'
      inputs:
        targetPath: '$(Build.ArtifactStagingDirectory)/frontend.zip'
        artifact: 'frontend'

    # -------- Backend --------
    - task: Cache@2
      displayName: 'BE: Restore npm cache'
      inputs:
        key: 'npm | server | $(Agent.OS) | $(Build.SourcesDirectory)/server/package-lock.json'
        path: '$(Pipeline.Workspace)/.npm'
        restoreKeys: |
          npm | server | $(Agent.OS)

    - script: |
        set -euo pipefail
        npm config set cache "$(npmCacheDir)"

        echo "Installing BE deps (lock-aware)..."
        if [ -f package-lock.json ]; then
          npm ci --legacy-peer-deps --prefer-offline --no-audit || npm install --legacy-peer-deps --prefer-offline --no-audit
        else
          npm install --legacy-peer-deps --prefer-offline --no-audit
        fi

        echo "Building BE..."
        npm run build

        # Assert dist exists
        [ -d dist ] || { echo "‚ùå BE dist/ not found after build"; ls -la; exit 1; }
        echo "‚úÖ BE dist/ present"

        echo "Creating deployment package..."
        rm -rf publish && mkdir publish

        # include lockfile for deterministic prod install
        cp package*.json publish/ 2>/dev/null || true
        [ -f package-lock.json ] && cp package-lock.json publish/ || true

        # Install prod deps deterministically (prefer ci when lockfile exists)
        if [ -f publish/package-lock.json ]; then
          npm ci --omit=dev --prefix publish --prefer-offline --no-audit || npm install --omit=dev --prefix publish --prefer-offline --no-audit
        else
          npm install --omit=dev --prefix publish --prefer-offline --no-audit
        fi

        cp -r dist publish/
        (cd publish && zip -r ../server.zip .)
        [ -f server.zip ] || { echo "‚ùå server.zip not created"; exit 1; }
        echo "‚úÖ server.zip created"
      workingDirectory: server
      displayName: 'BE: Build & Create slim ZIP'

    - task: PublishPipelineArtifact@1
      displayName: 'BE: Publish artifact'
      inputs:
        targetPath: '$(Build.SourcesDirectory)/server/server.zip'
        artifact: 'backend'

# =========================
# Stage 2: Frontend Deploy
# =========================
- stage: FrontendDeploy
  displayName: Deploy Frontend
  dependsOn: Build
  jobs:
  - job: DeployFrontend
    pool:
      name: 'inspect-connect-agents'
    steps:
    - checkout: none   # use artifact only

    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: 'frontend'
        path: '$(Pipeline.Workspace)/frontend'

    - task: AzureCLI@2
      displayName: 'FE: ZipDeploy (az webapp deploy) with retry'
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail
          az config set core.only_show_errors=true

          ZIP="$(Pipeline.Workspace)/frontend/frontend.zip"
          for i in 1 2 3; do
            echo "Deploy attempt $i ..."
            if az webapp deploy -g $(resourceGroupName) -n $(frontendAppName) --src-path "$ZIP" --type zip --restart true --timeout 1800; then
              echo "‚úÖ FE deploy succeeded"
              break
            fi
            echo "‚ö†Ô∏è  FE deploy failed (attempt $i). Retrying in 10s..."
            sleep 10
          done

          az webapp config appsettings set -g $(resourceGroupName) -n $(frontendAppName) --settings WEBSITES_PORT=8080
          az webapp config set -g $(resourceGroupName) -n $(frontendAppName) --startup-file "pm2 serve /home/site/wwwroot 8080 --spa --no-daemon"

    - task: AzureCLI@2
      displayName: 'FE: Resolve defaultHostName'
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail
          az config set core.only_show_errors=true
          HOST=$(az webapp show -g $(resourceGroupName) -n $(frontendAppName) --query defaultHostName -o tsv)
          echo "Resolved FE host: $HOST"
          echo "##vso[task.setvariable variable=FE_HOST]$HOST"

    - bash: |
        set -euo pipefail
        URL="https://$(FE_HOST)"
        echo "Probing $URL ..."
        for i in {1..30}; do
          code=$(curl -sS --connect-timeout 5 --max-time 15 -o /dev/null -w "%{http_code}" "$URL")
          if [ "$code" = "200" ] || [ "$code" = "301" ] || [ "$code" = "302" ]; then
            echo "Frontend reachable (HTTP $code)"
            break
          fi
          echo "Attempt $i: HTTP $code; retrying..."
          sleep 5
        done
        html=$(curl -fsSL --connect-timeout 5 --max-time 15 "$URL")
        echo "$html" | grep -qi "<title>" || { echo "Missing <title> in HTML"; exit 1; }
      displayName: 'FE: Smoke check'

# =========================
# Stage 3: Backend Deploy
# =========================
- stage: BackendDeploy
  displayName: Deploy Backend
  dependsOn: Build
  jobs:
  - job: DeployBackend
    pool:
      name: 'inspect-connect-agents'
    steps:
    - checkout: none   # use artifact only

    - task: DownloadPipelineArtifact@2
      inputs:
        artifact: 'backend'
        path: '$(Pipeline.Workspace)/backend'

    - bash: |
        set -euo pipefail
        echo "Pipeline.Workspace => $(Pipeline.Workspace)"
        ls -lah "$(Pipeline.Workspace)/backend" || true

        ZIP="$(Pipeline.Workspace)/backend/server.zip"
        if [ ! -f "$ZIP" ]; then
          echo "‚ùå server.zip not found under backend/"
          ls -la "$(Pipeline.Workspace)/backend/" || true
          exit 1
        fi

        TMP_FILE="$(mktemp)"; trap 'rm -f "$TMP_FILE"' EXIT
        echo "‚úÖ server.zip found, checking contents..."
        unzip -l "$ZIP" > "$TMP_FILE" 2>/dev/null || true

        if grep -qE "package\.json|(^| )dist/|node_modules" "$TMP_FILE"; then
          echo "‚úÖ Found expected entries (package.json, dist/, node_modules)"
          grep -E "package\.json|(^| )dist/|node_modules" "$TMP_FILE" | head -n 50 || true
          echo "‚úÖ Artifact sanity check passed"
        else
          echo "‚ùå Expected files not found in server.zip"
          exit 1
        fi
      displayName: 'BE: Sanity-check artifact'

    - task: AzureCLI@2
      displayName: 'BE: az webapp deploy (Run-From-Package) with retry'
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail
          az config set core.only_show_errors=true
          
          # Configure basic web app settings
          echo "Configuring web app settings..."
          az webapp config set -g $(resourceGroupName) -n $(backendAppName) --linux-fx-version "NODE|20-lts"
          az webapp config set -g $(resourceGroupName) -n $(backendAppName) --startup-file "npm run prod"
          
          # Web app is enabled by default, no need to set it explicitly

          ZIP="$(Pipeline.Workspace)/backend/server.zip"
          for i in 1 2 3; do
            echo "Deploy attempt $i ..."
            if az webapp deploy -g $(resourceGroupName) -n $(backendAppName) --src-path "$ZIP" --type zip --restart true --timeout 1800; then
              echo "‚úÖ BE deploy succeeded"
              break
            fi
            echo "‚ö†Ô∏è  BE deploy failed (attempt $i). Retrying in 10s..."
            sleep 10
          done
          
          # Set environment variables AFTER deployment
          echo "Setting environment variables..."
          az webapp config appsettings set -g $(resourceGroupName) -n $(backendAppName) --settings \
            WEBSITE_RUN_FROM_PACKAGE=1 \
            WEBSITE_NODE_DEFAULT_VERSION="~20" \
            NODE_ENV=production \
            WEBSITES_PORT=5002 \
            MONGODB_URI="$(MONGODB_URI)" \
            JWT_SECRET="$(JWT_SECRET)" \
            SENDGRID_API_KEY="$(SENDGRID_API_KEY)" \
            FROM_EMAIL="$(FROM_EMAIL)" \
            TWILIO_ACCOUNT_SID="$(TWILIO_ACCOUNT_SID)" \
            TWILIO_AUTH_TOKEN="$(TWILIO_AUTH_TOKEN)" \
            TWILIO_PHONE_NUMBER="$(TWILIO_PHONE_NUMBER)" \
            CLOUDINARY_CLOUD_NAME="$(CLOUDINARY_CLOUD_NAME)" \
            CLOUDINARY_API_KEY="$(CLOUDINARY_API_KEY)" \
            CLOUDINARY_API_SECRET="$(CLOUDINARY_API_SECRET)" \
            STRIPE_SECRET_KEY="$(STRIPE_SECRET_KEY)" \
            STRIPE_WEBHOOK_SECRET_KEY="$(STRIPE_WEBHOOK_SECRET_KEY)" \
            SALT_ROUNDS="$(SALT_ROUNDS)" \
            CLIENT_BASE_URL="$(CLIENT_BASE_URL)" \
            ENCRYPTION_KEY="$(ENCRYPTION_KEY)"
          
          # Verify environment variables are set
          echo "Verifying environment variables..."
          az webapp config appsettings list -g $(resourceGroupName) -n $(backendAppName) --query "[?name=='NODE_ENV' || name=='WEBSITES_PORT' || name=='MONGODB_URI']" -o table
          
          # Restart the web app to pick up new environment variables
          echo "Restarting web app to apply new settings..."
          az webapp restart -g $(resourceGroupName) -n $(backendAppName)
          
          # Give the app time to start up
          echo "Waiting for app to start up..."
          sleep 30
          
          # Check web app status and logs
          echo "Checking web app status..."
          az webapp show -g $(resourceGroupName) -n $(backendAppName) --query "{state:state,enabled:enabled,defaultHostName:defaultHostName}" -o table
          
          # Check if web app is running
          echo "Checking web app logs..."
          az webapp log tail -g $(resourceGroupName) -n $(backendAppName) --timeout 30 || echo "Log tail failed, checking recent logs..."
          
          # Get recent logs
          echo "Getting recent application logs..."
          az webapp log download -g $(resourceGroupName) -n $(backendAppName) --log-file app-logs.zip || echo "Log download failed"

    - task: AzureCLI@2
      displayName: 'BE: Resolve defaultHostName'
      inputs:
        azureSubscription: '$(azureSubscription)'
        scriptType: bash
        scriptLocation: inlineScript
        inlineScript: |
          set -euo pipefail
          az config set core.only_show_errors=true
          HOST=$(az webapp show -g $(resourceGroupName) -n $(backendAppName) --query defaultHostName -o tsv)
          echo "Resolved BE host: $HOST"
          echo "##vso[task.setvariable variable=BE_HOST]$HOST"

    - bash: |
        set -euo pipefail
        HEALTH_PATH="${HEALTH_PATH:-/health}"   # Use dedicated health endpoint
        URL="https://$(BE_HOST)${HEALTH_PATH}"
        echo "Probing $URL ..."
        
        # First, try the health endpoint
        for i in {1..15}; do
          echo "Health check attempt $i..."
          response=$(curl -sS --connect-timeout 10 --max-time 20 "$URL" 2>/dev/null || echo "")
          code=$(curl -sS --connect-timeout 10 --max-time 20 -o /dev/null -w "%{http_code}" "$URL" 2>/dev/null || echo "000")
          
          if [ "$code" = "200" ]; then
            echo "‚úÖ Backend healthy (HTTP 200)"
            echo "Response: $response"
            exit 0
          fi
          
          echo "Attempt $i: HTTP $code; response: $response"
          
          # If we get 403, try root endpoint as fallback
          if [ "$code" = "403" ] && [ "$HEALTH_PATH" = "/health" ]; then
            echo "Trying root endpoint as fallback..."
            root_code=$(curl -sS --connect-timeout 10 --max-time 20 -o /dev/null -w "%{http_code}" "https://$(BE_HOST)/" 2>/dev/null || echo "000")
            if [ "$root_code" = "200" ]; then
              echo "‚úÖ Backend healthy via root endpoint (HTTP 200)"
              exit 0
            fi
            echo "Root endpoint also failed: HTTP $root_code"
          fi
          
          sleep 10
        done
        
        # Final attempt with more verbose output
        echo "Final diagnostic attempt..."
        curl -v --connect-timeout 10 --max-time 20 "$URL" || true
        echo "Backend did not become healthy after 15 attempts"; exit 1
      displayName: 'BE: Smoke check'

# =========================
# Stage 4: Summary
# =========================
- stage: DeploymentSummary
  displayName: Deployment Summary
  dependsOn: [ FrontendDeploy, BackendDeploy ]
  jobs:
  - job: Summary
    pool:
      name: 'inspect-connect-agents'
    steps:
    - script: |
        echo "=============================================================================="
        echo "üéâ DEPLOYMENT COMPLETE"
        echo "=============================================================================="
        echo "Frontend URL (resolved at runtime)."
        echo "Backend  URL (resolved at runtime)."
        echo "Env: $(environment) | Build: $(Build.BuildNumber)"
      displayName: Summary

